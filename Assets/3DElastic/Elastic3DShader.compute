#pragma kernel Elastic3DDifferentials
#pragma kernel SetSourcePoint
#pragma kernel CopyBuffers
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct elasticMaterial
{
    float vp, vs, rho, lam, mu;
};

int3 to3d(int idx, int xSize, int ySize, int zSize)
{
    int z = idx / (xSize * ySize);
    int newIdx = idx - (z * xSize * ySize);
    int y = newIdx / xSize;
    int x = newIdx % xSize;
    return int3(x, y, z);
}


RWTexture2D<float4> velTexture;

RWStructuredBuffer<float3> u1Buffer;
RWStructuredBuffer<float3> u2Buffer;
RWStructuredBuffer<float3> u3Buffer;

RWStructuredBuffer<int> matGridBuffer;
RWStructuredBuffer<elasticMaterial> matDataBuffer;

RWStructuredBuffer<int3> sourcePosBuffer;
RWStructuredBuffer<float3> sourceValBuffer;


RWStructuredBuffer<float> weightBuffer;

float co_dx;
float co_dy;
float co_dz;

float dt;
float t;

int nx;
int nx2;
int ny;
int ny2;
int nz;
int nz2;

int to1d(int x, int y, int z)
{
    return (z * nx2 * ny2) + (y * nx2) + x;
}



[numthreads(256, 1, 1)]
void Elastic3DDifferentials(int3 id : SV_DispatchThreadID)
{
    
    
    int3 pos = to3d(id.x, nx2, ny2, nz2);
    int index = id.x;
    
    elasticMaterial material = matDataBuffer[matGridBuffer[index]];

    float lam = material.lam;
    float mu = material.mu;
    float lam_2mu = lam + 2.0 * mu;
    float dt2rho = dt * dt / material.rho;

    float lam_mu = lam + mu;
    
    int xOffset = 1;
    int yOffset = nx2;
    int zOffset = nx2 * ny2;
	
	
    //Central differencing 
    float3 du_dxx = 4*co_dx * co_dx * (u2Buffer[index + xOffset] - 2 * u2Buffer[index] + u2Buffer[index - xOffset]);
    float3 du_dyy = 4*co_dy * co_dy * (u2Buffer[index + yOffset] - 2 * u2Buffer[index] + u2Buffer[index - yOffset]);
    float3 du_dzz = 4*co_dz * co_dz * (u2Buffer[index + zOffset] - 2 * u2Buffer[index] + u2Buffer[index - zOffset]);
    
    // +1,+1 - +1,-1 - -1,+1 + -1,-1  

    float3 du_dxz = co_dx * co_dz * (u2Buffer[index + xOffset + zOffset] - u2Buffer[index + xOffset - zOffset] - u2Buffer[index - xOffset + zOffset] + u2Buffer[index - xOffset - zOffset]);
    float3 du_dyz = co_dy * co_dz * (u2Buffer[index + yOffset + zOffset] - u2Buffer[index + yOffset - zOffset] - u2Buffer[index - yOffset + zOffset] + u2Buffer[index - yOffset - zOffset]);
    float3 du_dxy = co_dx * co_dy * (u2Buffer[index + xOffset + yOffset] - u2Buffer[index + xOffset - yOffset] - u2Buffer[index - xOffset + yOffset] + u2Buffer[index - xOffset - yOffset]);

	//stress from velocity derivatives  
    float3 stress;

    stress.x = lam_2mu * du_dxx.x + mu * du_dyy.x + mu * du_dzz.x + lam_mu * du_dxz.z + lam_mu * du_dxy.y;
    stress.y = mu * du_dxx.y + lam_2mu * du_dyy.y + mu * du_dzz.y + lam_mu * du_dyz.z + lam_mu * du_dxy.x;
    stress.z = mu * du_dxx.z + mu * du_dyy.z + lam_2mu * du_dzz.z + lam_mu * du_dyz.y + lam_mu * du_dxz.x;

	//New velocity from stresses 
    //U(t) = 2 * U(t - 1) - U(t - 2) + G dt2 / rho
    u3Buffer[index] = 2.0 * u2Buffer[index] - u1Buffer[index] + stress * dt2rho;

}

[numthreads(8, 1, 1)]
void SetSourcePoint(uint3 id : SV_DispatchThreadID)
{
    int3 sPoint = sourcePosBuffer[id.x];
    uint idx = to1d(sPoint.x, sPoint.y, sPoint.z);
    u3Buffer[idx] += sourceValBuffer[id.x];
}


[numthreads(256, 1, 1)]
void CopyBuffers(uint3 id : SV_DispatchThreadID)
{
    int3 pos = to3d(id.x, nx2, ny2, nz2);
    int index = to1d(pos.x , pos.y , pos.z);
    
    u1Buffer[index] = u2Buffer[index] * weightBuffer[index];
    u2Buffer[index] = u3Buffer[index] * weightBuffer[index];
}